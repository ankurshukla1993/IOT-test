package org.parceler;

import android.os.Parcelable;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public final class Parcels {
    public static final String IMPL_EXT = "Parcelable";
    private static final ParcelCodeRepository REPOSITORY = new ParcelCodeRepository();

    public interface ParcelableFactory<T> {
        public static final String BUILD_PARCELABLE = "buildParcelable";

        Parcelable buildParcelable(T t);
    }

    private static final class ParcelCodeRepository {
        private ConcurrentMap<Class, ParcelableFactory> generatedMap;

        private ParcelCodeRepository() {
            this.generatedMap = new ConcurrentHashMap();
        }

        public ParcelableFactory get(Class clazz) {
            ParcelableFactory result = (ParcelableFactory) this.generatedMap.get(clazz);
            if (result != null) {
                return result;
            }
            ParcelableFactory value = findClass(clazz);
            if (Parcelable.class.isAssignableFrom(clazz)) {
                value = new ParcelableParcelableFactory();
            }
            if (value == null) {
                throw new ParcelerRuntimeException("Unable to find generated Parcelable class for " + clazz.getName() + ", verify that your class is configured properly and that the Parcelable class " + buildParcelableImplName(clazz) + " is generated by Parceler.");
            }
            result = (ParcelableFactory) this.generatedMap.putIfAbsent(clazz, value);
            if (result == null) {
                return value;
            }
            return result;
        }

        private static String buildParcelableImplName(Class clazz) {
            return clazz.getName() + "$$" + Parcels.IMPL_EXT;
        }

        public ParcelableFactory findClass(Class clazz) {
            try {
                return new ParcelableFactoryReflectionProxy(clazz, Class.forName(buildParcelableImplName(clazz)));
            } catch (ClassNotFoundException e) {
                return null;
            }
        }

        public void loadRepository(Repository<ParcelableFactory> repository) {
            this.generatedMap.putAll(repository.get());
        }
    }

    private static final class ParcelableFactoryReflectionProxy<T> implements ParcelableFactory<T> {
        private final Constructor<? extends Parcelable> constructor;

        public ParcelableFactoryReflectionProxy(Class<T> parcelClass, Class<? extends Parcelable> parcelWrapperClass) {
            try {
                this.constructor = parcelWrapperClass.getConstructor(new Class[]{parcelClass});
            } catch (NoSuchMethodException e) {
                throw new ParcelerRuntimeException("Unable to create ParcelFactory Type", e);
            }
        }

        public Parcelable buildParcelable(T input) {
            try {
                return (Parcelable) this.constructor.newInstance(new Object[]{input});
            } catch (InstantiationException e) {
                throw new ParcelerRuntimeException("Unable to create ParcelFactory Type", e);
            } catch (IllegalAccessException e2) {
                throw new ParcelerRuntimeException("Unable to create ParcelFactory Type", e2);
            } catch (InvocationTargetException e3) {
                throw new ParcelerRuntimeException("Unable to create ParcelFactory Type", e3);
            }
        }
    }

    static {
        REPOSITORY.loadRepository(NonParcelRepository.getInstance());
    }

    private Parcels() {
    }

    public static <T> Parcelable wrap(T input) {
        if (input == null) {
            return null;
        }
        return wrap(input.getClass(), input);
    }

    public static <T> Parcelable wrap(Class<? extends T> inputType, T input) {
        if (input == null) {
            return null;
        }
        return REPOSITORY.get(inputType).buildParcelable(input);
    }

    public static <T> T unwrap(Parcelable input) {
        if (input == null) {
            return null;
        }
        return ((ParcelWrapper) input).getParcel();
    }
}
